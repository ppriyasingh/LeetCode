Round 1:
1.)
Stream of Integers------- for every K integer you have to print maximum & minimum for a given window k.

K= 3
1,2, 3, 4, 5, 6, 7.......

min-1 , max - 3
min - 2, max - 4

minHeap: [1,0], [2,1], [3
maxHeap: 3, 2, 1


2.)
Given: [ate, tea, eat, cat, tac, bob]. Club together all the anagrams.

O/P: [[tea, ate, eat], [cat,tac], [bob]]

a,1
t,1
e,1

t,1
e,1
a,1

[aet,aet,aet,cat,cat,bbo]
aet, <0,1,2>
cat, <3,4>
bbo <5>

String sortString(String str) {
	char[] ch= str.toCharArray();
  Arrays.sort(ch);					//O(W log W)
  return new String(ch);
}

List<List<String>> anagrams(List<String> list){

    List<List<String>> result= new ArrayList();
    
		if(list.size()==0) return result;										
    
    HashMap<String, List<Integer>> freq= new HashMap<>();
    
    for(int i=0; i<list.size(); i++) {														//ate		//2. tea		//					// O(N)*(W log W)
    	String sortedString= sortString(list.get(i));									//aet
      List<Integer> listOfIndex= freq.getOrDefault(sortedString, new ArrayList<>());
      listOfIndex.add(i);																					// aet <0, 1>
      freq.put(sortedString, listOfIndex);
    }
    
    for(String key: freq.keySet()) {
    	List<String> subResult= ArrayList();
      
      for(int index: freq.get(key)) {
      	subResult(list.get(index));
      }
      result.add(subResult);
    }
    
    return result;

}

3.) 
Given a linked list & your are given integer value x, you have print the the th postion node from last

1->2->3->4->5
x = 2
o/p: 4


class Node{
	int val;
  Node next;
}

//x=7
int xthNodeFromLats(Node head, int x){
		if(head==null) return -1;
    
		int lenghtOfNode=0, len=0;
    Node temp= head;
    
    while(temp!=null) {
    	len++;		
      temp=temp.next;
    }
    
    if(len<x) return -1;
    
    temp= head;
    int i=0;
    
    while(i<len-x+1) {		//len-x+1=4
    	i++;
    	temp=temp.next;
    }
		return temp.val
}




Round 2:

1.)
How hashmap works in java? Write all internal code.

<Integer, String>
<1, Madhurima>
<2, Abhishek>
  
1. Hashmap: key-value pair
2. Methods: get(key)


a==b & a.equals(b)


2.)
Queue: 1, 2, 3, dequeue(), 4, 5, DQ(), 

Enqueue: O(1)
Dequeue: O(n)

Stack1: 4, 5, 
Stack2: 3, 2,

class Queue{
		Stack<Integer> stack1, stack2;
        
    public Queue() {
    	stack1= new Stack<Integer>;
      stack2= new Stack<Integer>;
      
    }
    
    public void enqueue(int key) {
    	stack1.push(key);
    }
    
    public int dequeue() {
    
    	if(stack2.isEmpty()) {
      	while(!stack1.isEmpty())
        	stack2.push(stack1.pop());
      }
      
      return stack2.pop();
      
    }
    
}


stack: 1 2 pop() 3 pop() 4 5 pop() pop()

Q1: 1 4 
Q2: 

Queue temp= 


3.)
public int[] increment(int[] digits) {

	if(digits.length==0) return digits;
  
	int j= digits.length-1;
  
  while(j>=0) {
  	if(digits[j]==9) {
    	digits[j]=0;
    } else {							// 000
    	digits[j]++;
      return digits;
    }
    j--;
    }
    
    if(j<0) {
    	int[] ans= new int[digits.length+1];     
      ans[0]=1;
    }
    return ans;
    
  }
}


123- 124
9499- 9500
999- 1000











